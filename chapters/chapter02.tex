\section{一些插入功能}
\subsection{插入公式}
行内公式$v-\varepsilon+\phi=2$。

插入行间公式如\autoref{Euler}：
\begin{equation}
    v-\varepsilon+\phi=2
    \label{Euler}
\end{equation}

\subsection{插入图片}
SWJTU校徽如\autoref{SWJTU}所示，注意这里使用了\verb|~\autoref{}|命令，也就是会自动生成“图”“式”等前缀，无需手动输入。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width =0.4\textwidth]{figures/swjtu_logo2.pdf}
    \caption{西南交通大学}
    \label{SWJTU}
\end{figure}

插入上面图片的代码：

\begin{verbatim}
    \begin{figure}[!htbp]
        \centering
        \includegraphics[width =0.4\textwidth]{figures/ucas_logo.pdf}
        \caption{西南交通大学}
        \label{SWJTU}
    \end{figure}
\end{verbatim}

\subsection{插入文本框}
本模板定义了一个圆角灰底的文本框，使用简化命令\verb|\tbox{}|即可，如果你不喜欢，可以前往 \texttt{swjtuReport.sty}对其进行修改。

\tbox{
    这是一个圆角灰底的文本框
}

\subsection{插入表格}
本模板文件如\autoref{doc}所示。11月11修改为三线表样式示例，更符合swjtu论文要求。
\begin{table}[!htbp]
    \centering % 将整个表格居中
    \renewcommand{\arraystretch}{1.5} % 将行高增加到原来的1.5倍
    \begin{tabular}{>{\centering\arraybackslash}p{5cm} >{\centering\arraybackslash}p{5cm}} % 每列5cm宽，文字居中  
    \hline
        文件名 & 说明 \\
        \hline
        \texttt{main.tex}  & 主文件 \\
        \texttt{references.bib} & 参考文献 \\
        \texttt{swjtuReport.sty}  & 文档格式控制\\
        \texttt{figures}  & 图片文件夹 \\
        \hline
    \end{tabular}
    \caption{本模板文件组成}
    \label{doc}
\end{table}


\subsection{插入数学逻辑环境}
\begin{Theorem}   % 定理
\end{Theorem}

\begin{Lemma}   % 引理
\end{Lemma}

\begin{Corollary}   % 推论
\end{Corollary}

\begin{Proposition}   % 命题
\end{Proposition}

\begin{Definition}   % 定义
\end{Definition}

\begin{Example}   % 例
\end{Example}

\begin{proof}   %证明
\end{proof}

\subsection{插入参考文献}
直接使用\verb|\cite{}|即可。

例如：
此处引用了文献\cite{kincaid2002numerical}。此处引用了文献\cite{2016The}.引用过的文献会自动出现在参考文献中。


\subsection{11月11号新增样式：定理框和代码}
定理框样式如\cref{intermediate_value_theorem}所示。注意引用定理要用\verb|~\cref{}|
\begin{tcolorbox}
\begin{Theorem}
 若 $f$ 是区间 $[a, b]$ 上的连续函数，且 $f(a) f(b) < 0$，则 $f$ 在 $(a, b)$ 内必有一个零点。
 \label{intermediate_value_theorem}
\end{Theorem}
\end{tcolorbox}

python代码样式如下：
\begin{lstlisting}[language=Python]
def bisection_method(f, a, b, tol=1e-6, maxiter=100):
    points = []  # 用于保存每次迭代的中点
    if f(a) * f(b) >= 0:
        print("f(a)和f(b)必须符号相反，以确保区间内有根。")
        return None
    for i in range(maxiter):
        c = (a + b) / 2  # 计算中点
        fc = f(c)
        points.append(c)  # 保存当前中点
        if abs(fc) < tol:  # 检查当前误差是否小于容差
            return c, points
        if f(a) * fc < 0:  # 根据符号判断根所在的区间
            b = c
        else:
            a = c
    # 若达到最大迭代次数仍未找到解，返回中点作为近似解
    return (a + b) / 2, points
\end{lstlisting}
